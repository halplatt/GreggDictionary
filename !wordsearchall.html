<!DOCTYPE html>
<!--
V2025.0911@11:37pm the driver is now !whordsearchall.json
V2025.0909@12:12pm prefetch data
V2025.0903@01:00pm add \w button
V2025.0827@2:52pm use include !shared-links.html
V2025.0825.1159pm rearanged buttons and fixed links
v2025.0528.0915pm fix insert character at cursor position
v=2025.0507.0109pm add link buttons to other tools
Version 02/12/2025 at 6:34pm Copyright notice
Version 02/07/2025 at 510pm Convert png names to lowercase, window.open
version 02/06/2025 at 9:18pm First version
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Search</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        #version {
            position: absolute;
            top: 10px;
            right: 75px;
            font-size: 0.8em;
            color: #888;
        }
        #regexInput {
            /* Allow the main input to shrink/grow so the row can stay on one line */
            flex: 1 1 360px; /* grow, shrink, preferred width */
            min-width: 220px; /* donâ€™t get too tiny */
            padding: 5px;
            margin-right: 10px;
        }
        #searchButton {
            padding: 5px 10px;
            background-color: #007bff;
            color: #fff;
            border: none;
            cursor: pointer;
        }

        #results {
            margin-top: 20px;
        }
        .result-item {
            margin-bottom: 10px;
        }
        .spinner {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
        }
        .bounce1, .bounce2, .bounce3 {
            width: 18px;
            height: 18px;
            background-color: #333;
            border-radius: 100%;
            display: inline-block;
            animation: bounce 1.4s infinite ease-in-out both;
        }
        .bounce1 {
            animation-delay: -0.32s;
        }
        .bounce2 {
            animation-delay: -0.16s;
        }
        @keyframes bounce {
            0%, 80%, 100% {
                transform: scale(0);
            }
            40% {
                transform: scale(1);
            }
        }
        .relative {
            position: relative;
        }
        .absolute {
            position: absolute;
        }
        .max-w-none {
            max-width: none;
        }
        .overflow-hidden {
            overflow: hidden;
        }
        .border {
            border: 1px solid black;
        }
        .max-w-screen {
            max-width: 100vw;
        }
        .overflow-x-auto {
            overflow-x: auto;
        }
        .expand-button {
            margin-top: 10px;
            padding: 5px 10px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
            /* these styles are for button and input row */
    .input-container {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
    }
    .button-row {
        display: flex;
        flex-wrap: wrap; /* Allow wrapping to the next line if needed */
        justify-content: flex-start;
        align-items: flex-end; /* align bottoms with radio buttons */
        width: 100%;
    }
    .inner {
    margin-right: 10px; /* Add spacing between links */
    display: inline-block; /* Ensure links are displayed inline */
    }
    .input-row {
        display: flex;
        align-items: center;
        flex-wrap: nowrap; /* keep controls on one line */
        gap: 10px;
        width: 100%;
        min-width: 0; /* allow flex children to shrink properly */
    }
    .button-row button {
        margin-right: 5px;
        padding: 2px 8px;        /* slimmer padding so buttons aren't tall */
        font-size: 16px;         /* keep characters readable */
        height: 30px;            /* target height */
        line-height: 26px;       /* vertical centering for glyphs */
        min-height: 0;           /* don't force taller than explicit height */
        box-sizing: border-box;
    }
    #caretButton {
        margin-right: 10px;
    }
    #addBegSetNot {
        margin-right: 5px;
    }
    #addEndSet {
        margin-right: 20px;
    }
    #addPipe {
        margin-right: 20px;
    }
    #addAnyChar {
        margin-right: 20px;
    }
    #add0or1 {
        margin-right: 10px;
    }
    .djs-item {
        margin-top: 10px;
        border-top: 1px solid #ccc; /* Add this line to create a line between list items */
        padding-top: 10px; /* Add some padding to separate the border from the content */
    }
    #divAboutText p {
        margin: 0;
        line-height: 1.2;
    }
    </style>
</head>
<body>
    <h1>Regex Search</h1>
    
    <p id="version">V2025.0911@11:37pm</p>

    <div class="input-container">
<!-- beg place holder where common links begin if page is in same directory as !shared-links.html -->
<div id="shared-links"></div>
<script>
(function loadSharedLinks() {
	const hostEl = document.getElementById('shared-links');
	if (!hostEl) return;

	fetch('./!shared-links.html', { cache: 'no-cache' })
		.then(r => (r.ok ? r.text() : Promise.reject(r)))
		.then(html => {
			// Replace all "~/" paths with "./" since this page is in the same directory
			hostEl.innerHTML = html.replace(/~\//g, './');
		})
		.catch(err => {
			console.error('Failed to load shared links:', err);
		});
})();
const public_domain_only = ''; // Declare this global variable to hide non-public domain links when it is set to 'pd'
</script>
<!-- end place holder where common links -->
    <br>
    <div class="input-container">
           <div class="button-row" style="margin-bottom:8px">
                <div class="search-type-group" style="margin-top: 15px; margin-right: 16px;">
                    <div class="search-type-title" style="font-weight:600; margin-bottom:6px;">Select search type</div>
                    <label style="margin-right:10px;"><input type="radio" name="searchType" value="contains" checked> Contains</label>
                    <label><input type="radio" name="searchType" value="exact"> Exact match</label>
                    <label style="margin-right:10px;"><input type="radio" name="searchType" value="beginsWith"> Begins with</label>
                    <label style="margin-right:10px;"><input type="radio" name="searchType" value="endsWith"> Ends with</label>
                    
                </div>
                <button id="addBegSet" onclick="addTextAtCursor('[')" title="Insert [ to begin a list of valid characters">[</button>
                <button id="addBegSetNot" onclick="addTextAtCursor('[^')" title="Insert [^ to begin a list of characters not valid in this position">[^</button>
                <button id="addEndSet" onclick="addTextAtCursor(']')" title="Insert ] to end a list of characters">]</button>
                <button id="addAnyChar" onclick="addTextAtCursor('\\w')" title="Insert \w to match any word character (letters, digits, or underscore)">\w</button>
                <button id="add0orMore" onclick="addTextAtCursor('*')" title="Insert * to indicate the previous character repeats 0 or more times">*</button>
                <button id="add1orMore" onclick="addTextAtCursor('+')" title="Insert + to indicate the previous character repeats 1 or more times">+</button>
                <button id="add0or1" onclick="addTextAtCursor('?')" title="Insert ? to indicate the previous character appears 0 or 1 times">?</button>                
                <button id="addPipe" onclick="addTextAtCursor('|')" title="Insert | to separate multiple patterns">|</button>
            </div>
        <div class="input-row">
            <input type="text" id="regexInput" placeholder="Enter text or regex">
            <button id="searchButton" onclick="searchWords()">Search</button>
            <label for="maxResults">Maximum Words:</label>
            <input type="number" id="maxResults" value="25" min="1" style="width: 50px;">
            <a href="../djsWords/!wordsearch_help.html" target="_blank">Help</a>
        </div>
    </div>
    <div id="results"></div>
    <textarea id="clipboardInput" style="position: absolute; left: -9999px;"></textarea>

    <script>
        const DISPLAY_SIZE_SMALL = { x: 365, y: 100, offset: 5 };
        const DISPLAY_SIZE_LARGE = { x: 450, y: 180, offset: 10 };
        const IMG_WIDTH = 1281;
        
        try {
                const folderName = 'all versions';

                document.title = `Regex Search of ${folderName}`;
                document.querySelector('h1').textContent = `Regex Search of ${folderName}`;
                document.querySelector('title').textContent = `Regex Search of ${folderName}`;
            } catch (error) {
                //document.title 
            }
        document.getElementById('regexInput').focus();
        document.getElementById('regexInput').select();

        document.getElementById('regexInput').addEventListener('keydown', function(event) {
            if (event.key === 'Enter') {
                searchWords();
            }
            try {
                // Attach caret/dollar update on input
                var regexInput = document.getElementById('regexInput');
            } catch (error) {
                // ignore   
            }
        });
        // Preload allData 
        let allData = null;
        const allDataReady = fetch('!wordsearchall.json', { cache: 'default' })
            .then(r => {
                if (!r.ok) throw new Error('Failed to load !wordsearchall.json');
                return r.json();
            })
            .then(json => (allData = json))
            .catch(err => {
                console.error('websearchall.json load error:', err);
                allData = [];
            });
        // Preload and cache reference data once at page load
        //beg functions needed for sim dictionary
        let simReferencejson = [];
        // Function to load JSON and assign to global variable
        function loadsimReferencejson() {
            fetch('./simDictionary/!reference.json')
                .then(response => response.json())
                .then(data => {
                    simReferencejson = data; // Now available globally
                    // You can call other functions here if needed
                })
                .catch(error => {
                    console.error('Error loading reference data:', error);
                });
        }

        // Run after DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            loadsimReferencejson();
        });
        function findPageByWord(searchValue) {
            const regex = new RegExp('^'+searchValue+'$', 'i');
            for (const page of simReferencejson) {
                for (const word of page.words) {
                    if (regex.test(word.t)) {
                        // Return the page object and the matching word object
                        return {
                            page: page.page,
                            word: word.t,
                            x: word.x,
                            y: word.y
                        };
                    }
                }
            }
            return null; // Not found
        }
        async function searchWords() {
            const regexInput = document.getElementById('regexInput');
            // Build a safe, sanitized regex from user input
            let rawPattern = regexInput.value;
            // Remove common invisible / zero-width characters & normalize Unicode
            const cleanedPattern = rawPattern
                .replace(/[\u200B\u200C\u200D\uFEFF]/g, '') // zeroâ€‘width chars
                .replace(/\r?\n/g, '')                       // stray newlines
                .normalize('NFC');
            let regex;
            try {
                regex = new RegExp(cleanedPattern, 'i');
            } catch(e) {
                console.warn('Invalid regex pattern, escaping literally:', cleanedPattern, e.message);
                const escaped = cleanedPattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                regex = new RegExp(escaped, 'i');
            }
            if (rawPattern !== cleanedPattern) {
                console.warn('Pattern sanitized (invisible chars removed):', { rawPattern, cleanedPattern, lengthRaw: rawPattern.length, lengthClean: cleanedPattern.length });
            }
            // Lightweight one-time debug for very short patterns when no matches occur
            const debugShortPattern = cleanedPattern.length <= 3;
            const resultsContainer = document.getElementById('results');
            const maxResults = parseInt(document.getElementById('maxResults').value, 10) || 25;
            resultsContainer.innerHTML = '';

            // Use preloaded data; wait for it if still loading
            const data = allData || (await allDataReady) || [];
            let resultCount = 0;
            let totalMatches = 0;

            for (const item of data) {
                const candidate = item.text
                    if (regex.test(candidate)) {
                        totalMatches++;
                        if (resultCount >= maxResults) {
                            continue;
                        }
                        resultCount++;


                        // Create DJS image
                        listItem = document.createElement("li");
                        listItem.className = 'djs-item';
                        listItem.textContent = 'djs: '+candidate;
                        listItem.addEventListener("click", (e) => copyToClipboard(candidate,'djs', e));
                        const imagePathdjs = 'djsWords/'; //path to word.png images
                        const img_djs = document.createElement("img");
                        img_djs.src = `${imagePathdjs}${candidate}.png`;
                        

                        img_djs.onerror = function() {
                            this.style.display = "none";  // Hide the image if it fails to load
                        };

                        // Add vertical align to the image based on the content of a corresponding text file
                        getVerticalAlign(img_djs.src).then(verticalAlign => {
                            img_djs.style.verticalAlign = verticalAlign;
                        });

                        listItem.appendChild(img_djs);
                        // Add the list item to the result list
                        resultsContainer.appendChild(listItem);



                       



                        // Create Simplified image
                        const objSim = findPageByWord(candidate);
                        
                        const resultItem = document.createElement('li');
                        //resultItem.className = 'result-item';
                        resultItem.innerHTML = `Simplified: ${candidate}`; // , X: ${word.x}, Y: ${word.y}`;
                        resultItem.addEventListener("click", () => copyToClipboard(candidate,'sim'));
                        if (objSim) {
                            

                            const outerContainer = document.createElement('div');
                            outerContainer.className = 'max-w-screen overflow-x-auto';

                            const imageContainer = document.createElement('div');
                            imageContainer.className = 'relative overflow-hidden border';
                            imageContainer.style.width = `${DISPLAY_SIZE_SMALL.x}px`;
                            imageContainer.style.height = `${DISPLAY_SIZE_SMALL.y}px`;

                            const img = document.createElement('img');
                            img.className = 'absolute max-w-none';
                            if (window.location.hostname == "halplatt.github.io") { //names must be lower case on github
                                img.src = `simDictionary/${objSim.page.toLowerCase()}.png`;
                            } else {
                                img.src = `simDictionary/${objSim.page}.png`;
                            }
                            img.alt = `Gregg shorthand for word: ${objSim.word}`;
                            img.style.top = `-${objSim.y - 50}px`; // Adjust to center the word vertically
                            img.style.left = `-${objSim.x - 182.5}px`; // Adjust to center the word horizontally
                            img.style.width = '1281px'; // Assuming the image width is fixed

                            img.onload = function() {
                                const scale = IMG_WIDTH / img.naturalWidth;
                                img.style.top = `-${objSim.y * scale - DISPLAY_SIZE_SMALL.y / 2}px`;
                                img.style.left = `-${objSim.x * scale - DISPLAY_SIZE_SMALL.offset}px`;
                                img.style.width = `${IMG_WIDTH}px`;
                            };

                            img.onclick = function() {

                                event.stopPropagation(); // Prevent the event from bubbling up to the resultItem
                                const clipboardInput = document.getElementById("clipboardInput");
                                clipboardInput.value = objSim.word;
                                clipboardInput.select();
                                document.execCommand("copy");
                                clipboardInput.value = "";                            
                                var url = `GreggDictionary.html?x=${objSim.word}&gsd=sim`;
                                var newTab=window.open(url, 'GreggDictionary');
                                newTab.focus();
                            };

                            const expandButton = document.createElement('button');
                            expandButton.className = 'expand-button';
                            expandButton.innerHTML = 'Expand';
                            expandButton.onclick = function() {
                                event.stopPropagation(); // Prevent the event from bubbling up to the resultItem
                                if (imageContainer.style.width === `${DISPLAY_SIZE_SMALL.x}px`) {
                                    imageContainer.style.width = `${DISPLAY_SIZE_LARGE.x}px`;
                                    imageContainer.style.height = `${DISPLAY_SIZE_LARGE.y}px`;
                                    img.style.top = `-${objSim.y * (IMG_WIDTH / img.naturalWidth) - DISPLAY_SIZE_LARGE.y / 2}px`;
                                    img.style.left = `-${objSim.x * (IMG_WIDTH / img.naturalWidth) - DISPLAY_SIZE_LARGE.offset}px`;
                                    expandButton.innerHTML = 'Shrink';
                                } else {
                                    imageContainer.style.width = `${DISPLAY_SIZE_SMALL.x}px`;
                                    imageContainer.style.height = `${DISPLAY_SIZE_SMALL.y}px`;
                                    img.style.top = `-${objSim.y * (IMG_WIDTH / img.naturalWidth) - DISPLAY_SIZE_SMALL.y / 2}px`;
                                    img.style.left = `-${objSim.x * (IMG_WIDTH / img.naturalWidth) - DISPLAY_SIZE_SMALL.offset}px`;
                                    expandButton.innerHTML = 'Expand';
                                }
                            };
                            imageContainer.appendChild(img);
                            outerContainer.appendChild(imageContainer);
                            outerContainer.appendChild(expandButton);
                            resultItem.appendChild(outerContainer);
                            
                        }
                        resultsContainer.appendChild(resultItem); 
                         // Create Anniversary image
                         listItem = document.createElement("li");
                        listItem.textContent = 'anniversary: '+candidate;
                        listItem.addEventListener("click", (e) => copyToClipboard(candidate,'ann', e));
                        const imagePathann = 'annWords/'; //path to word.png images
                        const img_ann = document.createElement("img");
                        img_ann.src = `${imagePathann}${candidate}.png`;
                        img_ann.onerror = function() {
                            this.style.display = "none";  // Hide the image if it fails to load
                        };

                        listItem.appendChild(img_ann);
                        // Add the list item to the result list
                        resultsContainer.appendChild(listItem);




                        // Create pre-Anniversary image
                         listItem = document.createElement("li");
                        listItem.textContent = 'pre-anniversary: '+candidate;
                        listItem.addEventListener("click", (e) => copyToClipboard(candidate,'pre', e));
                        const imagePathpre = 'preWords/'; //path to word.png images
                        const img_pre = document.createElement("img");
                        // For pre-anniversary we use the candidate directly (no page lookup performed)
                        img_pre.src = `${imagePathpre}${candidate}.png`;
                        

                        img_pre.onerror = function() {
            if (debugShortPattern && resultCount === 0) {
                // Detailed debug report for unexpected misses
                console.warn('DEBUG: No matches for short pattern. Char codes:', {
                    pattern: cleanedPattern,
                    patternCodes: Array.from(cleanedPattern, c => c.charCodeAt(0)),
                    sampleFirst5: data.slice(0,5).map(w => ({ word: w, codes: Array.from(String(w).normalize('NFC'), c => c.charCodeAt(0)) }))
                });
            }
                            this.style.display = "none";  // Hide the image if it fails to load
                        };

                        // Add vertical align to the image based on the content of a corresponding text file

                        listItem.appendChild(img_pre);
                        // Add the list item to the result list
                        resultsContainer.appendChild(listItem);
                    }
                
            }
            var aboutText = "";
            aboutText = aboutText.concat("<p><b>DJS images extracted from</b> <i>Gregg Shorthand Dictionary DJS,</i> a book published by The McGraw-Hill Publishing Company in 1963, written by Charles Rader. </p>");	
            aboutText = aboutText.concat("<p><b>Simplified images extracted from</b> <i>Gregg Shorthand Dictionary Simplified,</i> a book published by The Gregg Publishing Company in 1945, written by Charles Rader. </p>");
            aboutText = aboutText.concat("<p><i><b>Anniversary images extracted from</b> Gregg Shorthand Dictionary,</i> a book published by The Gregg Publishing Company in 1930, including 18667 shorthand forms written by Winifred Kenna Richmond.</p>");
            aboutText = aboutText.concat("<p><i><b>Pre-anniversary images extracted from</b> Gregg Shorthand Dictionary (1916),</i> a book published by The Gregg Publishing Company in 1916, including 17,000 shorthand forms written by Alice Rinne Hagar.</p>");
            const endMessage = document.createElement('div');
            const divAboutText = document.createElement('div');
            divAboutText.id = 'divAboutText';
            endMessage.className = 'result-item';
            if (resultCount === 0) {
                endMessage.textContent = 'No matches found';
                aboutText = ""
            } else if (resultCount < maxResults) {
                endMessage.textContent = `End of ${resultCount} matches`;
            } else {
                endMessage.textContent = `Max display limited to ${resultCount} of ${totalMatches} matches`;
            }
            divAboutText.innerHTML = aboutText;
            resultsContainer.appendChild(endMessage);
            resultsContainer.appendChild(divAboutText);
            regexInput.focus();
            regexInput.select();
        }
            // Radio-based search type control: sync with input anchors (^ at start, $ at end)
            function updateSearchTypeRadiosFromInput() {
                var el = document.getElementById('regexInput');
                if (!el) return;
                var v = el.value || '';
                var type = 'contains';
                if (v.startsWith('^') && v.endsWith('$') && v.length >= 2) {
                    type = 'exact';
                } else if (v.startsWith('^')) {
                    type = 'beginsWith';
                } else if (v.endsWith('$')) {
                    type = 'endsWith';
                }
                var radios = document.querySelectorAll('input[name="searchType"]');
                radios.forEach(function(r){ r.checked = (r.value === type); });
            }

            function applySearchTypeToInput(type) {
                var el = document.getElementById('regexInput');
                if (!el) return;
                var v = el.value || '';
                // Remove existing anchors first (only if at ends)
                if (v.startsWith('^')) v = v.substring(1);
                if (v.endsWith('$')) v = v.slice(0, -1);
                // Apply by type
                if (type === 'beginsWith') {
                    v = '^' + v;
                } else if (type === 'endsWith') {
                    v = v + '$';
                } else if (type === 'exact') {
                    v = '^' + v + '$';
                } // contains -> no anchors
                el.value = v;
                // Keep radios and focus in sync
                updateSearchTypeRadiosFromInput();
                el.focus();
                // Select all to make it easy to continue editing
                try { el.selectionStart = 0; el.selectionEnd = v.length; } catch(e) {}
            }
        // Function to add text at the cursor position or end of the text if no cursor position
        function addTextAtCursor(text) {
            var regexInput = document.getElementById('regexInput');
            regexInput.focus();
            var startPos = typeof regexInput.selectionStart === "number" ? regexInput.selectionStart : regexInput.value.length;
            var endPos = typeof regexInput.selectionEnd === "number" ? regexInput.selectionEnd : regexInput.value.length;
            // Insert the text after the selected text, not replacing it
            regexInput.value = 
                regexInput.value.substring(0, endPos) + 
                text + 
                regexInput.value.substring(endPos);
            // Set the cursor position to the end of the inserted text
            var cursorPos = endPos + text.length;
            regexInput.selectionStart = regexInput.selectionEnd = cursorPos;     
        }
        //add vertical align to the image based on the content of a corresponding text file 
        function getVerticalAlign(pngFile) {
                var txtFile = pngFile.replace('.png', '.txt');
                return fetch(txtFile)
                    .then(response => {
                        if (!response.ok) {
                            return '0px';
                        }
                        return response.text();
                    })
                    .then(px => (-1 * parseFloat(px.trim())) + 'px')  // Prepend a '-' to the number
                    .catch(() => '0px');
        }
        // Function to copy text to clipboard
        function copyToClipboard(text, globalGsd, ev) {
            try { if (ev && typeof ev.stopPropagation === 'function') ev.stopPropagation(); } catch(_) {}
            const clipboardInput = document.getElementById("clipboardInput");
            clipboardInput.value = text;
            clipboardInput.select();
            document.execCommand("copy");
            clipboardInput.value = "";
            openInNewTab(text, globalGsd);
        }
        //Function to open in new tab
        function openInNewTab(text,globalGsd) {
            url = './GreggDictionary.html?x=' + text + '&gsd=' + globalGsd;
            var newTab = window.open(url, 'GreggDictionary');
            newTab.focus();
        }
        // Function to open or focus a tab with the given URL and target
        function openOrFocusTab(url, target) {
            var newTab = window.open('', target);
            if (newTab.location.href === "about:blank") {
                newTab.location.href = url;
            } else {
                //do nothing, the tab is already open
            }
            newTab.focus();
        } 
        document.getElementById('regexInput').addEventListener('keydown', function(event) {
            if (event.key === 'Enter') {
                let regexInput = document.getElementById('regexInput');
                searchWords();
            }
            // Keyboard shortcuts for search type
            // Ctrl+Alt+X/P/S (Alt+Shift+X/P/S) -> exact/beginsWith/endsWith
            const ctrlAlt = (event.ctrlKey && event.altKey);
            const altShift = (!event.ctrlKey && event.altKey && event.shiftKey);
            if (ctrlAlt || altShift) {
                const k = event.key.toLowerCase();
                if (k === 'x') { event.preventDefault(); applySearchTypeToInput('exact'); return; }
                if (k === 'p') { event.preventDefault(); applySearchTypeToInput('beginsWith'); return; }
                if (k === 's') { event.preventDefault(); applySearchTypeToInput('endsWith'); return; }
            }
        });
        // Sync radios as user types or pastes anchors
        (function attachInputSync(){
            try {
                var el = document.getElementById('regexInput');
                if(!el) return;
                el.addEventListener('input', function(){
                    updateSearchTypeRadiosFromInput();
                });
            } catch(e) { /* ignore */ }
        })();
        // Handle radio changes to update input
        (function attachRadioHandlers(){
            try {
                var radios = document.querySelectorAll('input[name="searchType"]');
                radios.forEach(function(r){
                    r.addEventListener('change', function(ev){
                        if (ev.target.checked) {
                            applySearchTypeToInput(ev.target.value);
                        }
                    });
                });
                // Initial sync based on current input value
                updateSearchTypeRadiosFromInput();
            } catch(e) { /* ignore */ }
        })();
        // Allow pressing Enter in maxResults to trigger the same search routing as regexInput
        (function attachMaxResultsEnter(){
            try {
                const maxEl = document.getElementById('maxResults');
                if(!maxEl) return;
                maxEl.addEventListener('keydown', function(event){
                    if(event.key === 'Enter'){
                        const reEl = document.getElementById('regexInput');
                        if(!reEl) return;
                        const val = reEl.value || '';
                            searchWords();
                    }
                });
            } catch(e){ /* ignore */ }
        })();
        
        // Function to focus and select regex input
        function focusRegexInput() {
            const regexInput = document.getElementById('regexInput');
            if (regexInput) {
                regexInput.focus();
                regexInput.select();
            }
        }
        
        // Focus on regex input when page loads - placed at end of document
        window.addEventListener('load', function() {
            const regexInput = document.getElementById('regexInput');
            if (regexInput) {
                regexInput.focus();
                regexInput.select();
                // Initial sync of radio group with current input
                updateSearchTypeRadiosFromInput();
            }
        });
        
        // Focus regex input when page receives focus
        window.addEventListener('focus', function() {
            focusRegexInput();
        });
        
        // Focus regex input when user clicks anywhere on the page (except specific elements)
        document.addEventListener('click', function(event) {
            // Don't refocus if clicking on the input itself, buttons, links, or interactive elements
            const clickedElement = event.target;
            if (clickedElement.tagName === 'INPUT' || 
                clickedElement.tagName === 'BUTTON' || 
                clickedElement.tagName === 'A' || 
                clickedElement.tagName === 'IMG' ||
                clickedElement.closest('button') ||
                clickedElement.closest('a') ||
                clickedElement.closest('.result-item') ||
                clickedElement.closest('.expand-button')) {
                return; // Don't refocus if clicking on interactive elements
            }
            
            // Small delay to ensure other click events complete first
            setTimeout(focusRegexInput, 50);
        });
        // Insert attribution / copyright notice based on globalGsd
        (function addAttributionFooter(){
            try {
                var footer = document.getElementById('resultsFooter');
                if(!footer) return; // nothing to do
                if(footer.dataset.populated) return; // already done
                const aboutText = document.createElement('div');
                aboutText.className = 'about-text';
                if (globalGsd === 'sim') {
                    aboutText.innerHTML = "<p><b>Images from</b> <i>Gregg Shorthand Dictionary Simplified</i>, a book published by The Gregg Publishing Company in 1945, written by Charles Rader.</p>";
                } else if (globalGsd === 'ann') {
                    aboutText.innerHTML = "<p><b>Images from</b> <i>Gregg Shorthand Dictionary Anniversary</i>, a book published by The Gregg Publishing Company in 1929, written by John Robert Gregg.</p>";
                } else if (globalGsd === 'pre') {
                    aboutText.innerHTML = "<p><i><b>Images from</b> Gregg Shorthand Dictionary (1916),</i> a book published by The Gregg Publishing Company in 1916, including 17,000 shorthand forms written by Alice Rinne Hagar</p>";
                } else {
                    aboutText.innerHTML = "<p><b>Images Source:</b> Gregg Shorthand reference materials.</p>";
                }
                footer.appendChild(aboutText);
                footer.dataset.populated = '1';
            } catch(e) {
                // silently ignore
            }
        })();
    </script>
</body>
</html>